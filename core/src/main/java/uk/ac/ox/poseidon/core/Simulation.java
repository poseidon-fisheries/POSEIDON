/*
 * POSEIDON: an agent-based model of fisheries
 * Copyright (c) 2024-2025, University of Oxford.
 *
 * University of Oxford means the Chancellor, Masters and Scholars of the
 * University of Oxford, having an administrative office at Wellington
 * Square, Oxford OX1 2JD, UK.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * This source file was generated by the Gradle 'init' task
 */
package uk.ac.ox.poseidon.core;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import lombok.Getter;
import sim.engine.SimState;
import sim.engine.Steppable;
import uk.ac.ox.poseidon.core.events.EventManager;
import uk.ac.ox.poseidon.core.events.SimpleEventManager;
import uk.ac.ox.poseidon.core.schedule.TemporalSchedule;

import java.io.Serial;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Stream;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.ImmutableSet.toImmutableSet;

@Getter
public class Simulation extends SimState {

    @Serial private static final long serialVersionUID = -8162246985852120341L;
    private static final AtomicLong idCounter = new AtomicLong();
    private final EventManager eventManager = new SimpleEventManager();
    private final TemporalSchedule temporalSchedule;
    private final Scenario scenario;
    private final long id = idCounter.getAndIncrement();
    private final List<Steppable> finalProcesses = new ArrayList<>();
    private boolean started = false;
    private List<?> components;

    public Simulation() {
        this(
            System.currentTimeMillis(),
            LocalDate.now().atStartOfDay(),
            new Scenario()
        );
    }

    public Simulation(
        final long seed,
        final LocalDateTime startingDateTime,
        final Scenario scenario
    ) {
        this(
            seed,
            new TemporalSchedule(startingDateTime), scenario
        );
    }

    @SuppressFBWarnings("EI_EXPOSE_REP2")
    public Simulation(
        final long seed,
        final TemporalSchedule schedule,
        final Scenario scenario
    ) {
        super(seed, schedule);
        this.temporalSchedule = checkNotNull(schedule);
        this.scenario = scenario;
    }

    @Override
    public void start() {
        if (started) throw new IllegalStateException("Simulation already started.");
        super.start();
        this.components =
            scenario
                .getComponents()
                .values()
                .stream()
                .map(factory -> factory.get(this))
                .toList();
        started = true;
    }

    public void addFinalProcess(final Steppable process) {
        finalProcesses.add(process);
    }

    public void addFinalProcess(final Runnable process) {
        finalProcesses.add(simState -> process.run());
    }

    @Override
    public void finish() {
        finalProcesses.forEach(process -> process.step(this));
        super.finish();
    }

    @Override
    public final int hashCode() {
        return super.hashCode();
    }

    @Override
    public final boolean equals(final Object obj) {
        return super.equals(obj);
    }

    private <T> Stream<T> getComponents(
        final Collection<?> component,
        final Class<T> componentClass
    ) {
        return component
            .stream()
            .flatMap(o ->
                o instanceof final Collection<?> c
                    ? getComponents(c, componentClass)
                    : Stream.of(o)
            )
            .filter(componentClass::isInstance)
            .map(componentClass::cast);
    }

    public <T> Set<T> getComponents(final Class<T> componentClass) {
        return getComponents(components, componentClass).collect(toImmutableSet());
    }

    public <T> T getComponent(
        final Class<T> componentClass
    ) {
        final Set<T> components = getComponents(componentClass);
        if (components.isEmpty()) {
            throw new NoSuchElementException(
                "Component of class " +
                    componentClass.getName() +
                    " not found in simulation."
            );
        }
        if (components.size() > 1) {
            throw new IllegalStateException(
                "More than one component of class " +
                    componentClass.getName() +
                    " found in simulation."
            );
        }
        return components.iterator().next();
    }

}
