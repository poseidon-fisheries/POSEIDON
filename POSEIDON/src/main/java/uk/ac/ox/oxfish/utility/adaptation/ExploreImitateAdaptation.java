/*
 *     POSEIDON, an agent-based model of fisheries
 *     Copyright (C) 2017  CoHESyS Lab cohesys.lab@gmail.com
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 */

package uk.ac.ox.oxfish.utility.adaptation;

import ec.util.MersenneTwisterFast;
import uk.ac.ox.oxfish.fisher.Fisher;
import uk.ac.ox.oxfish.fisher.selfanalysis.ObjectiveFunction;
import uk.ac.ox.oxfish.model.FishState;
import uk.ac.ox.oxfish.utility.adaptation.maximization.AdaptationAlgorithm;
import uk.ac.ox.oxfish.utility.adaptation.probability.AdaptationProbability;
import uk.ac.ox.oxfish.utility.adaptation.probability.FixedProbability;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map.Entry;
import java.util.function.Function;
import java.util.function.Predicate;

import static uk.ac.ox.oxfish.utility.FishStateUtilities.entry;

/**
 * A general algorithm to perform exploration/imitation/exploitation decisions possibly on a specific variable
 * Created by carrknight on 8/6/15.
 */
public class ExploreImitateAdaptation<T> extends AbstractAdaptation<T> {


    /**
     * what the agent ought to do to adapt
     */
    private final AdaptationAlgorithm<T> algorithm;
    /**
     * how the agent should judge himself and others
     */
    private final ObjectiveFunction<Fisher> objective;
    private final AdaptationProbability probability;
    /**
     * checks that the T generated by exploration is valid
     */
    private final Predicate<T> explorationCheck;
    /**
     * function to grab eligible friends
     */
    private Function<Entry<Fisher, MersenneTwisterFast>, Collection<Fisher>> friendsExtractor;
    /**
     * holds the starting point of a randomization
     */
    private Entry<T, Double> explorationStart;
    private ImitationStart<T> imitationStart;
    /**
     * the last action taken was this kind of action
     */
    private ExploreImitateStatus status;

    public ExploreImitateAdaptation(
        final Predicate<Fisher> validator,
        final AdaptationAlgorithm<T> decision,
        final Actuator<Fisher, T> actuator,
        final Sensor<Fisher, T> sensor,
        final ObjectiveFunction<Fisher> objective, final double explorationProbability,
        final double imitationProbability, final Predicate<T> explorationValidator
    ) {

        this(validator,
            decision, actuator, sensor, objective,
            new FixedProbability(explorationProbability, imitationProbability),
            explorationValidator,
            input -> input.getKey().getDirectedFriends()
        );

    }

    public ExploreImitateAdaptation(
        final Predicate<Fisher> validator,
        final AdaptationAlgorithm<T> decision,
        final Actuator<Fisher, T> actuator, final Sensor<Fisher, T> sensor,
        final ObjectiveFunction<Fisher> objective,
        final AdaptationProbability probability,
        final Predicate<T> explorationValidator,
        final Function<Entry<Fisher, MersenneTwisterFast>, Collection<Fisher>> friendsExtractor
    ) {
        super(sensor, actuator, validator);
        this.friendsExtractor = friendsExtractor;
        this.algorithm = decision;
        this.objective = objective;
        this.probability = probability;
        this.explorationCheck = explorationValidator;
    }

    public ExploreImitateAdaptation(
        final Predicate<Fisher> validator,
        final AdaptationAlgorithm<T> decision,
        final Actuator<Fisher, T> actuator,
        final Sensor<Fisher, T> sensor,
        final ObjectiveFunction<Fisher> objective,
        final AdaptationProbability probability, final Predicate<T> explorationValidator
    ) {
        this(validator, decision, actuator, sensor, objective, probability,
            explorationValidator,
            input -> input.getKey().getDirectedFriends()
        );

    }

    @Override
    public T concreteAdaptation(final Fisher toAdapt, final FishState state, final MersenneTwisterFast random) {

        //check your fitness and where you are
        double fitness = objective.computeCurrentFitness(toAdapt, toAdapt);
        T current = getSensor().scan(toAdapt);

        //if you explored in the previous step
        if (explorationStart != null) {
            assert imitationStart == null;
            assert status == ExploreImitateStatus.EXPLORING;


            final Double previousFitness = explorationStart.getValue();
            final T previous = explorationStart.getKey();
            final T decision = this.algorithm.judgeRandomization(random, toAdapt,
                previousFitness,
                fitness,
                previous,
                current
            );

            this.probability.judgeExploration(previousFitness, fitness);

            explorationStart = null;


            if (decision != null) {
                if (decision == previous)
                    fitness = previousFitness;
                current = decision;
            }
            assert current != null;
        }

        //if you imitated in the previous step
        else if (imitationStart != null) {
            assert explorationStart == null;
            assert status == ExploreImitateStatus.IMITATING;
            final double previousFitness = imitationStart.getPreviousFitness();
            final T previous = imitationStart.getPreviousDecision();
            final T decision = this.algorithm.judgeImitation(random, toAdapt,
                imitationStart.getFriend(),
                previousFitness,
                fitness,
                previous,
                current
            );

            imitationStart = null;
            if (decision != null) {
                if (decision == previous)
                    fitness = previousFitness;
                current = decision;

            }

        }

        //you have no previous decisions to judge or you had but decided not to act upon them
        //you are now ready to check whether to explore or exploit

        final double explorationProbability = probability.getExplorationProbability();
        //explore?
        if (explorationProbability > 0 && random.nextBoolean(explorationProbability)) {

            // reject failed attempts up to a limit of 20
            int attempts = 0;

            while (attempts < 100) {
                final T future = algorithm.randomize(random, toAdapt, fitness, current);
                if (explorationCheck.test(future)) {
                    explorationStart = entry(current, fitness);
                    status = ExploreImitateStatus.EXPLORING;
                    return future;
                }
                attempts++;
            }
            //failed: nowhere valid to explore!
            status = ExploreImitateStatus.EXPLOITING;
            return null;

        }

        assert explorationStart == null;

        //imitate?
        final double imitationProbability = probability.getImitationProbability();

        //get your friends (but not those that have been banned from fishing)
        //todo might want to make this as a funtion of time since last out rather than allowed at sea
        Collection<Fisher> friends = friendsExtractor.apply(entry(toAdapt, random));
        if (friends != null) {
            final List<Fisher> list = new ArrayList<>();
            for (final Fisher friend : friends) {
                if (friend.isAllowedAtSea()) {
                    list.add(friend);
                }
            }
            friends = list;
        }

        if (imitationProbability > 0 && friends != null &&
            !friends.isEmpty() && random.nextBoolean(imitationProbability)) {


            final Entry<T, Fisher> imitation = algorithm.imitate(random,
                toAdapt, fitness, current,
                friends, objective, getSensor()
            );
            //if there is somebody to imitate and the imitation does not involve just doing what I am doing anyway
            if (imitation.getValue() != null
                && !imitation.getKey().equals(current)
                && explorationCheck.test(imitation.getKey())) {
                imitationStart = new ImitationStart<>(imitation.getValue(), fitness, imitation.getKey());

                status = ExploreImitateStatus.IMITATING;
                return imitation.getKey();
            }

        }

        //exploit
        status = ExploreImitateStatus.EXPLOITING;
        return current;
    }

    public void onStart(final FishState state, final Fisher toAdapt) {
        algorithm.start(state, toAdapt,
            getSensor().scan(toAdapt)
        );
        probability.start(state, toAdapt);
    }


    @Override
    public void turnOff(final Fisher fisher) {

        probability.turnOff(fisher);
    }


    public Function<Entry<Fisher, MersenneTwisterFast>, Collection<Fisher>> getFriendsExtractor() {
        return friendsExtractor;
    }

    public void setFriendsExtractor(
        final Function<Entry<Fisher, MersenneTwisterFast>, Collection<Fisher>> friendsExtractor
    ) {
        this.friendsExtractor = friendsExtractor;
    }

    public AdaptationAlgorithm<T> getAlgorithm() {
        return algorithm;
    }


    public ObjectiveFunction<Fisher> getObjective() {
        return objective;
    }


    public Entry<T, Double> getExplorationStart() {
        return explorationStart;
    }

    public void setExplorationStart(final Entry<T, Double> explorationStart) {
        this.explorationStart = explorationStart;
    }

    /**
     * Getter for property 'status'.
     *
     * @return Value for property 'status'.
     */
    public ExploreImitateStatus getStatus() {
        return status;
    }

    /**
     * Getter for property 'explorationCheck'.
     *
     * @return Value for property 'explorationCheck'.
     */
    public Predicate<T> getExplorationCheck() {
        return explorationCheck;
    }

    private class ImitationStart<K> {
        private final Fisher friend;
        private final double previousFitness;
        private final K previousDecision;

        public ImitationStart(final Fisher friend, final double previousFitness, final K previousDecision) {
            this.friend = friend;
            this.previousFitness = previousFitness;
            this.previousDecision = previousDecision;
        }

        public Fisher getFriend() {
            return friend;
        }

        public double getPreviousFitness() {
            return previousFitness;
        }

        public K getPreviousDecision() {
            return previousDecision;
        }
    }
}
