/*
 *     POSEIDON, an agent-based model of fisheries
 *     Copyright (C) 2017  CoHESyS Lab cohesys.lab@gmail.com
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 */

package uk.ac.ox.oxfish.fisher.strategies.destination;

import uk.ac.ox.oxfish.fisher.DockingListener;
import uk.ac.ox.oxfish.fisher.Fisher;
import uk.ac.ox.oxfish.fisher.selfanalysis.ObjectiveFunction;
import uk.ac.ox.oxfish.geography.SeaTile;
import uk.ac.ox.oxfish.geography.ports.Port;
import uk.ac.ox.oxfish.model.FishState;
import uk.ac.ox.oxfish.utility.adaptation.ExploreImitateAdaptation;
import uk.ac.ox.oxfish.utility.adaptation.maximization.AdaptationAlgorithm;
import uk.ac.ox.oxfish.utility.adaptation.probability.AdaptationProbability;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 *
 * In reality just a facade for a specialized PerTripIterativeDestination Strategy with an imitative algorithm.
 * Uses docking event to count (so basically only counts finished trips)
 * Created by carrknight on 6/11/17.
 */
public class ExploreExploitImitateDestinationStrategy extends PerTripIterativeDestinationStrategy implements
        DockingListener {


    public final static String EXPLORING_COLUMN_NAME = "Trips Exploring";
    public final static String EXPLOITING_COLUMN_NAME = "Trips Exploiting";
    public final static String IMITATING_COLUMN_NAME = "Trips Imitating";


    private final ExploreImitateAdaptation<SeaTile> adaptation;

    /**
     * if this is set, the very first destination cannot be further from port than this number
     */
    private final double initialMaxDistance;

    private final Predicate<SeaTile> explorationValidator;


    public ExploreExploitImitateDestinationStrategy(
            FavoriteDestinationStrategy delegate,
            AdaptationAlgorithm<SeaTile> algorithm,
            AdaptationProbability probability,
            final ObjectiveFunction<Fisher> objective,
            final Predicate<SeaTile> explorationValidator,
            final boolean ignoreFailedTrips,
            double initialMaxDistance)
    {
        super(delegate, algorithm, probability, objective, explorationValidator, ignoreFailedTrips);
        this.initialMaxDistance = initialMaxDistance;
        this.adaptation = ((ExploreImitateAdaptation<SeaTile>) super.getAlgorithm());
        this.explorationValidator = explorationValidator;
    }






    @Override
    public void start(FishState model, Fisher fisher) {
        super.start(model, fisher);
        fisher.addDockingListener(this);
        //if this column doesn't exist, then create them in the counter!
        if (!fisher.getYearlyCounter().hasColumn(EXPLORING_COLUMN_NAME)) {
            fisher.getYearlyCounter().addColumn(EXPLORING_COLUMN_NAME);
            fisher.getYearlyCounter().addColumn(EXPLOITING_COLUMN_NAME);
            fisher.getYearlyCounter().addColumn(IMITATING_COLUMN_NAME);

        } else {
            assert fisher.getYearlyCounter().hasColumn(EXPLOITING_COLUMN_NAME);
            assert fisher.getYearlyCounter().hasColumn(IMITATING_COLUMN_NAME);
        }
        //if there is an initial max distance, use it now!
        //check that the initial random spot is valid from an exploration point of view

        double threshold = Double.isFinite(initialMaxDistance) && initialMaxDistance>0 ? initialMaxDistance : Double.MAX_VALUE;
        while(
                (
                        model.getMap().distance(getDelegate().getFavoriteSpot(),
                                                fisher.getHomePort().getLocation()) > threshold) ||
                        !explorationValidator.test(getDelegate().getFavoriteSpot()))
        {

            List<SeaTile> validSeatiles = model.getMap().getAllSeaTilesExcludingLandAsList().stream().filter(
                    new Predicate<SeaTile>() {
                        @Override
                        public boolean test(SeaTile seaTile) {
                            return model.getMap().distance(
                                    seaTile,
                                    fisher.getHomePort().getLocation()
                            ) < threshold;
                        }
                    }
            ).filter(
                    new Predicate<SeaTile>() {
                        @Override
                        public boolean test(SeaTile seaTile) {
                            return explorationValidator.test(seaTile);
                        }
                    }
            ).collect(Collectors.toList());


            getDelegate().setFavoriteSpot(
                    validSeatiles.get(model.random.nextInt(validSeatiles.size()))
            );


        }



    }

    /**
     * tell the startable to turnoff,
     *
     * @param fisher
     */
    @Override
    public void turnOff(Fisher fisher) {
        super.turnOff(fisher);
        fisher.removeDockingListener(this);
    }

    //count as a finished exploratory/imitative/explotative trip
    @Override
    public void dockingEvent(Fisher fisher, Port port) {
        if(adaptation.getStatus()!=null)
            switch(adaptation.getStatus())
            {
                case IMITATING:
                    fisher.getYearlyCounter().count(IMITATING_COLUMN_NAME,1);
                    break;
                default:
                case EXPLORING:
                    fisher.getYearlyCounter().count(EXPLORING_COLUMN_NAME,1);
                    break;
                case EXPLOITING:
                    fisher.getYearlyCounter().count(EXPLOITING_COLUMN_NAME,1);
                    break;
            }
    }
}
